!function(name, definition) {
  if(typeof define == "function") {
    define(definition)
  }else {
    if(typeof module != "undefined") {
      module.exports = definition()
    }else {
      this[name] = this["domReady"] = definition()
    }
  }
}("domready", function(ready) {
  var fns = [], fn, f = false, doc = document, testEl = doc.documentElement, hack = testEl.doScroll, domContentLoaded = "DOMContentLoaded", addEventListener = "addEventListener", onreadystatechange = "onreadystatechange", loaded = /^loade|c/.test(doc.readyState);
  function flush(f) {
    loaded = 1;
    while(f = fns.shift()) {
      f()
    }
  }
  doc[addEventListener] && doc[addEventListener](domContentLoaded, fn = function() {
    doc.removeEventListener(domContentLoaded, fn, f);
    flush()
  }, f);
  hack && doc.attachEvent(onreadystatechange, fn = function() {
    if(/^c/.test(doc.readyState)) {
      doc.detachEvent(onreadystatechange, fn);
      flush()
    }
  });
  return ready = hack ? function(fn) {
    self != top ? loaded ? fn() : fns.push(fn) : function() {
      try {
        testEl.doScroll("left")
      }catch(e) {
        return setTimeout(function() {
          ready(fn)
        }, 50)
      }
      fn()
    }()
  } : function(fn) {
    loaded ? fn() : fns.push(fn)
  }
});
!function(name, definition) {
  if(typeof module != "undefined") {
    module.exports = definition()
  }else {
    if(typeof define == "function" && typeof define.amd == "object") {
      define(definition)
    }else {
      this[name] = definition()
    }
  }
}("qwery", function() {
  var context = this, doc = document, old = context.qwery, html = doc.documentElement, byClass = "getElementsByClassName", byTag = "getElementsByTagName", byId = "getElementById", qSA = "querySelectorAll", id = /#([\w\-]+)/, clas = /\.[\w\-]+/g, idOnly = /^#([\w\-]+)$/, classOnly = /^\.([\w\-]+)$/, tagOnly = /^([\w\-]+)$/, tagAndOrClass = /^([\w]+)?\.([\w\-]+)$/, easy = new RegExp(idOnly.source + "|" + tagOnly.source + "|" + classOnly.source), splittable = /(^|,)\s*[>~+]/, normalizr = /^\s+|\s*([,\s\+\~>]|$)\s*/g, 
  splitters = /[\s\>\+\~]/, splittersMore = /(?![\s\w\-\/\?\&\=\:\.\(\)\!,@#%<>\{\}\$\*\^'"]*\]|[\s\w\+\-]*\))/, specialChars = /([.*+?\^=!:${}()|\[\]\/\\])/g, simple = /^([a-z0-9]+)?(?:([\.\#]+[\w\-\.#]+)?)/, attr = /\[([\w\-]+)(?:([\|\^\$\*\~]?\=)['"]?([ \w\-\/\?\&\=\:\.\(\)\!,@#%<>\{\}\$\*\^]+)["']?)?\]/, pseudo = /:([\w\-]+)(\(['"]?([\s\w\+\-]+)['"]?\))?/, dividers = new RegExp("(" + splitters.source + ")" + splittersMore.source, "g"), tokenizr = new RegExp(splitters.source + splittersMore.source), 
  chunker = new RegExp(simple.source + "(" + attr.source + ")?" + "(" + pseudo.source + ")?"), walker = {" ":function(node) {
    return node && node !== html && node.parentNode
  }, ">":function(node, contestant) {
    return node && node.parentNode == contestant.parentNode && node.parentNode
  }, "~":function(node) {
    return node && node.previousSibling
  }, "+":function(node, contestant, p1, p2) {
    if(!node) {
      return false
    }
    return(p1 = previous(node)) && (p2 = previous(contestant)) && p1 == p2 && p1
  }};
  function cache() {
    this.c = {}
  }
  cache.prototype = {g:function(k) {
    return this.c[k] || undefined
  }, s:function(k, v) {
    return this.c[k] = v
  }};
  var classCache = new cache, cleanCache = new cache, attrCache = new cache, tokenCache = new cache;
  function classRegex(c) {
    return classCache.g(c) || classCache.s(c, new RegExp("(^|\\s+)" + c + "(\\s+|$)"))
  }
  function each(a, fn) {
    var i = 0, l = a.length;
    for(;i < l;i++) {
      fn.call(null, a[i])
    }
  }
  function flatten(ar) {
    var r = [];
    each(ar, function(a) {
      if(arrayLike(a)) {
        r = r.concat(a)
      }else {
        r[r.length] = a
      }
    });
    return r
  }
  function arrayify(ar) {
    var i = 0, l = ar.length, r = [];
    for(;i < l;i++) {
      r[i] = ar[i]
    }
    return r
  }
  function previous(n) {
    while(n = n.previousSibling) {
      if(n.nodeType == 1) {
        break
      }
    }
    return n
  }
  function q(query) {
    return query.match(chunker)
  }
  function interpret(whole, tag, idsAndClasses, wholeAttribute, attribute, qualifier, value, wholePseudo, pseudo, wholePseudoVal, pseudoVal) {
    var i, m, k, o, classes;
    if(tag && this.tagName.toLowerCase() !== tag) {
      return false
    }
    if(idsAndClasses && (m = idsAndClasses.match(id)) && m[1] !== this.id) {
      return false
    }
    if(idsAndClasses && (classes = idsAndClasses.match(clas))) {
      for(i = classes.length;i--;) {
        if(!classRegex(classes[i].slice(1)).test(this.className)) {
          return false
        }
      }
    }
    if(pseudo && qwery.pseudos[pseudo] && !qwery.pseudos[pseudo](this, pseudoVal)) {
      return false
    }
    if(wholeAttribute && !value) {
      o = this.attributes;
      for(k in o) {
        if(Object.prototype.hasOwnProperty.call(o, k) && (o[k].name || k) == attribute) {
          return this
        }
      }
    }
    if(wholeAttribute && !checkAttr(qualifier, getAttr(this, attribute) || "", value)) {
      return false
    }
    return this
  }
  function clean(s) {
    return cleanCache.g(s) || cleanCache.s(s, s.replace(specialChars, "\\$1"))
  }
  function checkAttr(qualify, actual, val) {
    switch(qualify) {
      case "=":
        return actual == val;
      case "^=":
        return actual.match(attrCache.g("^=" + val) || attrCache.s("^=" + val, new RegExp("^" + clean(val))));
      case "$=":
        return actual.match(attrCache.g("$=" + val) || attrCache.s("$=" + val, new RegExp(clean(val) + "$")));
      case "*=":
        return actual.match(attrCache.g(val) || attrCache.s(val, new RegExp(clean(val))));
      case "~=":
        return actual.match(attrCache.g("~=" + val) || attrCache.s("~=" + val, new RegExp("(?:^|\\s+)" + clean(val) + "(?:\\s+|$)")));
      case "|=":
        return actual.match(attrCache.g("|=" + val) || attrCache.s("|=" + val, new RegExp("^" + clean(val) + "(-|$)")))
    }
    return 0
  }
  function _qwery(selector) {
    var r = [], ret = [], i, l, m, token, tag, els, root, intr, item, tokens = tokenCache.g(selector) || tokenCache.s(selector, selector.split(tokenizr)), dividedTokens = selector.match(dividers);
    if(!tokens.length) {
      return r
    }
    tokens = tokens.slice(0);
    token = tokens.pop();
    root = tokens.length && (m = tokens[tokens.length - 1].match(idOnly)) ? doc[byId](m[1]) : doc;
    if(!root) {
      return r
    }
    intr = q(token);
    els = root.nodeType !== 9 && dividedTokens && /^[+~]$/.test(dividedTokens[dividedTokens.length - 1]) ? function(r) {
      while(root = root.nextSibling) {
        root.nodeType == 1 && (intr[1] ? intr[1] == root.tagName.toLowerCase() : 1) && (r[r.length] = root)
      }
      return r
    }([]) : root[byTag](intr[1] || "*");
    for(i = 0, l = els.length;i < l;i++) {
      if(item = interpret.apply(els[i], intr)) {
        r[r.length] = item
      }
    }
    if(!tokens.length) {
      return r
    }
    each(r, function(e) {
      if(ancestorMatch(e, tokens, dividedTokens)) {
        ret[ret.length] = e
      }
    });
    return ret
  }
  function is(el, selector, root) {
    if(isNode(selector)) {
      return el == selector
    }
    if(arrayLike(selector)) {
      return!!~flatten(selector).indexOf(el)
    }
    var selectors = selector.split(","), tokens, dividedTokens;
    while(selector = selectors.pop()) {
      tokens = tokenCache.g(selector) || tokenCache.s(selector, selector.split(tokenizr));
      dividedTokens = selector.match(dividers);
      tokens = tokens.slice(0);
      if(interpret.apply(el, q(tokens.pop())) && (!tokens.length || ancestorMatch(el, tokens, dividedTokens, root))) {
        return true
      }
    }
  }
  function ancestorMatch(el, tokens, dividedTokens, root) {
    var cand;
    function crawl(e, i, p) {
      while(p = walker[dividedTokens[i]](p, e)) {
        if(isNode(p) && (found = interpret.apply(p, q(tokens[i])))) {
          if(i) {
            if(cand = crawl(p, i - 1, p)) {
              return cand
            }
          }else {
            return p
          }
        }
      }
    }
    return(cand = crawl(el, tokens.length - 1, el)) && (!root || isAncestor(cand, root))
  }
  function isNode(el) {
    return el && typeof el === "object" && el.nodeType && (el.nodeType == 1 || el.nodeType == 9)
  }
  function uniq(ar) {
    var a = [], i, j;
    label:for(i = 0;i < ar.length;i++) {
      for(j = 0;j < a.length;j++) {
        if(a[j] == ar[i]) {
          continue label
        }
      }
      a[a.length] = ar[i]
    }
    return a
  }
  function arrayLike(o) {
    return typeof o === "object" && isFinite(o.length)
  }
  function normalizeRoot(root) {
    if(!root) {
      return doc
    }
    if(typeof root == "string") {
      return qwery(root)[0]
    }
    if(arrayLike(root)) {
      return root[0]
    }
    return root
  }
  function qwery(selector, _root) {
    var m, el, root = normalizeRoot(_root);
    if(!root || !selector) {
      return[]
    }
    if(selector === window || isNode(selector)) {
      return!_root || selector !== window && isNode(root) && isAncestor(selector, root) ? [selector] : []
    }
    if(selector && arrayLike(selector)) {
      return flatten(selector)
    }
    if(m = selector.match(easy)) {
      if(m[1]) {
        return(el = doc[byId](m[1])) ? [el] : []
      }
      if(m[2]) {
        return arrayify(root[byTag](m[2]))
      }
      if(supportsCSS3 && m[3]) {
        return arrayify(root[byClass](m[3]))
      }
    }
    return select(selector, root)
  }
  function collectSelector(root, collector) {
    return function(s) {
      var oid, nid;
      if(splittable.test(s)) {
        if(root !== doc) {
          if(!(nid = oid = root.getAttribute("id"))) {
            root.setAttribute("id", nid = "__qwerymeupscotty")
          }
          s = "#" + nid + s;
          collector(doc, s);
          oid || root.removeAttribute("id")
        }
        return
      }
      s.length && collector(root, s)
    }
  }
  var isAncestor = "compareDocumentPosition" in html ? function(element, container) {
    return(container.compareDocumentPosition(element) & 16) == 16
  } : "contains" in html ? function(element, container) {
    container = container == doc || container == window ? html : container;
    return container !== element && container.contains(element)
  } : function(element, container) {
    while(element = element.parentNode) {
      if(element === container) {
        return 1
      }
    }
    return 0
  }, getAttr = function() {
    var e = doc.createElement("p");
    return(e.innerHTML = '<a href="#x">x</a>') && e.firstChild.getAttribute("href") != "#x" ? function(e, a) {
      return a === "class" ? e.className : a === "href" || a === "src" ? e.getAttribute(a, 2) : e.getAttribute(a)
    } : function(e, a) {
      return e.getAttribute(a)
    }
  }(), supportsCSS3 = function() {
    try {
      return doc[byClass] && doc.querySelector && doc[qSA] && doc[qSA](":nth-of-type(1)").length
    }catch(e) {
      return false
    }
  }(), select = supportsCSS3 ? function(selector, root) {
    var result = [], ss, e;
    if(root === doc || !splittable.test(selector)) {
      return arrayify(root[qSA](selector))
    }
    each(ss = selector.split(","), collectSelector(root, function(ctx, s) {
      e = ctx[qSA](s);
      if(e.length == 1) {
        result[result.length] = e.item(0)
      }else {
        if(e.length) {
          result = result.concat(arrayify(e))
        }
      }
    }));
    return ss.length > 1 && result.length > 1 ? uniq(result) : result
  } : function(selector, root) {
    var result = [], m, i, l, r, ss;
    selector = selector.replace(normalizr, "$1");
    if(m = selector.match(tagAndOrClass)) {
      if(root[qSA]) {
        return arrayify(root[qSA](selector))
      }
      r = classRegex(m[2]);
      items = root[byTag](m[1] || "*");
      for(i = 0, l = items.length;i < l;i++) {
        if(r.test(items[i].className)) {
          result[result.length] = items[i]
        }
      }
      return result
    }
    each(ss = selector.split(","), collectSelector(root, function(ctx, s) {
      var i = 0, r = _qwery(s), l = r.length;
      for(;i < l;i++) {
        if(ctx === doc || isAncestor(r[i], root)) {
          result[result.length] = r[i]
        }
      }
    }));
    return ss.length > 1 && result.length > 1 ? uniq(result) : result
  };
  qwery.uniq = uniq;
  qwery.is = is;
  qwery.pseudos = {};
  qwery.noConflict = function() {
    context.qwery = old;
    return this
  };
  return qwery
});
!function(name, definition) {
  if(typeof module != "undefined") {
    module.exports = definition()
  }else {
    if(typeof define == "function" && typeof define.amd == "object") {
      define(definition)
    }else {
      this[name] = definition()
    }
  }
}("bean", function() {
  var win = window, __uid = 1, registry = {}, collected = {}, overOut = /over|out/, namespace = /[^\.]*(?=\..*)\.|.*/, stripName = /\..*/, addEvent = "addEventListener", attachEvent = "attachEvent", removeEvent = "removeEventListener", detachEvent = "detachEvent", doc = document || {}, root = doc.documentElement || {}, W3C_MODEL = root[addEvent], eventSupport = W3C_MODEL ? addEvent : attachEvent, isDescendant = function(parent, child) {
    var node = child.parentNode;
    while(node !== null) {
      if(node == parent) {
        return true
      }
      node = node.parentNode
    }
  }, retrieveUid = function(obj, uid) {
    return obj.__uid = uid && uid + "::" + __uid++ || obj.__uid || __uid++
  }, retrieveEvents = function(element) {
    var uid = retrieveUid(element);
    return registry[uid] = registry[uid] || {}
  }, listener = W3C_MODEL ? function(element, type, fn, add) {
    element[add ? addEvent : removeEvent](type, fn, false)
  } : function(element, type, fn, add, custom) {
    if(custom && add && element["_on" + custom] === null) {
      element["_on" + custom] = 0
    }
    element[add ? attachEvent : detachEvent]("on" + type, fn)
  }, nativeHandler = function(element, fn, args) {
    return function(event) {
      event = fixEvent(event || ((this.ownerDocument || this.document || this).parentWindow || win).event);
      return fn.apply(element, [event].concat(args))
    }
  }, customHandler = function(element, fn, type, condition, args) {
    return function(event) {
      if(condition ? condition.apply(this, arguments) : W3C_MODEL ? true : event && event.propertyName == "_on" + type || !event) {
        event = event ? fixEvent(event || ((this.ownerDocument || this.document || this).parentWindow || win).event) : null;
        fn.apply(element, Array.prototype.slice.call(arguments, event ? 0 : 1).concat(args))
      }
    }
  }, addListener = function(element, orgType, fn, args) {
    var type = orgType.replace(stripName, ""), events = retrieveEvents(element), handlers = events[type] || (events[type] = {}), originalFn = fn, uid = retrieveUid(fn, orgType.replace(namespace, ""));
    if(handlers[uid]) {
      return element
    }
    var custom = customEvents[type];
    if(custom) {
      fn = custom.condition ? customHandler(element, fn, type, custom.condition) : fn;
      type = custom.base || type
    }
    var isNative = nativeEvents[type];
    fn = isNative ? nativeHandler(element, fn, args) : customHandler(element, fn, type, false, args);
    isNative = W3C_MODEL || isNative;
    if(type == "unload") {
      var org = fn;
      fn = function() {
        removeListener(element, type, fn) && org()
      }
    }
    element[eventSupport] && listener(element, isNative ? type : "propertychange", fn, true, !isNative && type);
    handlers[uid] = fn;
    fn.__uid = uid;
    fn.__originalFn = originalFn;
    return type == "unload" ? element : collected[retrieveUid(element)] = element
  }, removeListener = function(element, orgType, handler) {
    var uid, names, uids, i, events = retrieveEvents(element), type = orgType.replace(stripName, "");
    if(!events || !events[type]) {
      return element
    }
    names = orgType.replace(namespace, "");
    uids = names ? names.split(".") : [handler.__uid];
    function destroyHandler(uid) {
      handler = events[type][uid];
      if(!handler) {
        return
      }
      delete events[type][uid];
      if(element[eventSupport]) {
        type = customEvents[type] ? customEvents[type].base : type;
        var isNative = W3C_MODEL || nativeEvents[type];
        listener(element, isNative ? type : "propertychange", handler, false, !isNative && type)
      }
    }
    destroyHandler(names);
    for(i = uids.length;i--;destroyHandler(uids[i])) {
    }
    return element
  }, del = function(selector, fn, $) {
    return function(e) {
      var array = typeof selector == "string" ? $(selector, this) : selector;
      for(var target = e.target;target && target != this;target = target.parentNode) {
        for(var i = array.length;i--;) {
          if(array[i] == target) {
            return fn.apply(target, arguments)
          }
        }
      }
    }
  }, add = function(element, events, fn, delfn, $) {
    if(typeof events == "object" && !fn) {
      for(var type in events) {
        events.hasOwnProperty(type) && add(element, type, events[type])
      }
    }else {
      var isDel = typeof fn == "string", types = (isDel ? fn : events).split(" ");
      fn = isDel ? del(events, delfn, $) : fn;
      for(var i = types.length;i--;) {
        addListener(element, types[i], fn, Array.prototype.slice.call(arguments, isDel ? 4 : 3))
      }
    }
    return element
  }, remove = function(element, orgEvents, fn) {
    var k, m, type, events, i, isString = typeof orgEvents == "string", names = isString && orgEvents.replace(namespace, ""), rm = removeListener, attached = retrieveEvents(element);
    names = names && names.split(".");
    if(isString && /\s/.test(orgEvents)) {
      orgEvents = orgEvents.split(" ");
      i = orgEvents.length - 1;
      while(remove(element, orgEvents[i]) && i--) {
      }
      return element
    }
    events = isString ? orgEvents.replace(stripName, "") : orgEvents;
    if(!attached || names || isString && !attached[events]) {
      for(k in attached) {
        if(attached.hasOwnProperty(k)) {
          for(i in attached[k]) {
            for(m = names.length;m--;) {
              attached[k].hasOwnProperty(i) && (new RegExp("^" + names[m] + "::\\d*(\\..*)?$")).test(i) && rm(element, [k, i].join("."))
            }
          }
        }
      }
      return element
    }
    if(typeof fn == "function") {
      rm(element, events, fn)
    }else {
      if(names) {
        rm(element, orgEvents)
      }else {
        rm = events ? rm : remove;
        type = isString && events;
        events = events ? fn || attached[events] || events : attached;
        for(k in events) {
          if(events.hasOwnProperty(k)) {
            rm(element, type || k, events[k]);
            delete events[k]
          }
        }
      }
    }
    return element
  }, fire = function(element, type, args) {
    var evt, k, i, m, types = type.split(" ");
    for(i = types.length;i--;) {
      type = types[i].replace(stripName, "");
      var isNative = nativeEvents[type], isNamespace = types[i].replace(namespace, ""), handlers = retrieveEvents(element)[type];
      if(isNamespace) {
        isNamespace = isNamespace.split(".");
        for(k = isNamespace.length;k--;) {
          for(m in handlers) {
            handlers.hasOwnProperty(m) && (new RegExp("^" + isNamespace[k] + "::\\d*(\\..*)?$")).test(m) && handlers[m].apply(element, [false].concat(args))
          }
        }
      }else {
        if(!args && element[eventSupport]) {
          fireListener(isNative, type, element)
        }else {
          for(k in handlers) {
            handlers.hasOwnProperty(k) && handlers[k].apply(element, [false].concat(args))
          }
        }
      }
    }
    return element
  }, fireListener = W3C_MODEL ? function(isNative, type, element) {
    evt = document.createEvent(isNative ? "HTMLEvents" : "UIEvents");
    evt[isNative ? "initEvent" : "initUIEvent"](type, true, true, win, 1);
    element.dispatchEvent(evt)
  } : function(isNative, type, element) {
    isNative ? element.fireEvent("on" + type, document.createEventObject()) : element["_on" + type]++
  }, clone = function(element, from, type) {
    var events = retrieveEvents(from), obj, k;
    var uid = retrieveUid(element);
    obj = type ? events[type] : events;
    for(k in obj) {
      obj.hasOwnProperty(k) && (type ? add : clone)(element, type || from, type ? obj[k].__originalFn : k)
    }
    return element
  }, fixEvent = function(e) {
    var result = {};
    if(!e) {
      return result
    }
    var type = e.type, target = e.target || e.srcElement;
    result.preventDefault = fixEvent.preventDefault(e);
    result.stopPropagation = fixEvent.stopPropagation(e);
    result.target = target && target.nodeType == 3 ? target.parentNode : target;
    if(~type.indexOf("key")) {
      result.keyCode = e.which || e.keyCode
    }else {
      if(/click|mouse|menu/i.test(type)) {
        result.rightClick = e.which == 3 || e.button == 2;
        result.pos = {x:0, y:0};
        if(e.pageX || e.pageY) {
          result.clientX = e.pageX;
          result.clientY = e.pageY
        }else {
          if(e.clientX || e.clientY) {
            result.clientX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            result.clientY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop
          }
        }
        overOut.test(type) && (result.relatedTarget = e.relatedTarget || e[(type == "mouseover" ? "from" : "to") + "Element"])
      }
    }
    for(var k in e) {
      if(!(k in result)) {
        result[k] = e[k]
      }
    }
    return result
  };
  fixEvent.preventDefault = function(e) {
    return function() {
      if(e.preventDefault) {
        e.preventDefault()
      }else {
        e.returnValue = false
      }
    }
  };
  fixEvent.stopPropagation = function(e) {
    return function() {
      if(e.stopPropagation) {
        e.stopPropagation()
      }else {
        e.cancelBubble = true
      }
    }
  };
  var nativeEvents = {click:1, dblclick:1, mouseup:1, mousedown:1, contextmenu:1, mousewheel:1, DOMMouseScroll:1, mouseover:1, mouseout:1, mousemove:1, selectstart:1, selectend:1, keydown:1, keypress:1, keyup:1, orientationchange:1, touchstart:1, touchmove:1, touchend:1, touchcancel:1, gesturestart:1, gesturechange:1, gestureend:1, focus:1, blur:1, change:1, reset:1, select:1, submit:1, load:1, unload:1, beforeunload:1, resize:1, move:1, DOMContentLoaded:1, readystatechange:1, error:1, abort:1, scroll:1};
  function check(event) {
    var related = event.relatedTarget;
    if(!related) {
      return related === null
    }
    return related != this && related.prefix != "xul" && !/document/.test(this.toString()) && !isDescendant(this, related)
  }
  var customEvents = {mouseenter:{base:"mouseover", condition:check}, mouseleave:{base:"mouseout", condition:check}, mousewheel:{base:/Firefox/.test(navigator.userAgent) ? "DOMMouseScroll" : "mousewheel"}};
  var bean = {add:add, remove:remove, clone:clone, fire:fire};
  var clean = function(el) {
    var uid = remove(el).__uid;
    if(uid) {
      delete collected[uid];
      delete registry[uid]
    }
  };
  if(win[attachEvent]) {
    add(win, "unload", function() {
      for(var k in collected) {
        collected.hasOwnProperty(k) && clean(collected[k])
      }
      win.CollectGarbage && CollectGarbage()
    })
  }
  bean.noConflict = function() {
    context.bean = old;
    return this
  };
  return bean
});
(function() {
  var root = this;
  var previousUnderscore = root._;
  var breaker = {};
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
  var slice = ArrayProto.slice, unshift = ArrayProto.unshift, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
  var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
  var _ = function(obj) {
    return new wrapper(obj)
  };
  if(typeof exports !== "undefined") {
    if(typeof module !== "undefined" && module.exports) {
      exports = module.exports = _
    }
    exports._ = _
  }else {
    if(typeof define === "function" && define.amd) {
      define("underscore", function() {
        return _
      })
    }else {
      root["_"] = _
    }
  }
  _.VERSION = "1.2.1";
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if(obj == null) {
      return
    }
    if(nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context)
    }else {
      if(obj.length === +obj.length) {
        for(var i = 0, l = obj.length;i < l;i++) {
          if(i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
            return
          }
        }
      }else {
        for(var key in obj) {
          if(hasOwnProperty.call(obj, key)) {
            if(iterator.call(context, obj[key], key, obj) === breaker) {
              return
            }
          }
        }
      }
    }
  };
  _.map = function(obj, iterator, context) {
    var results = [];
    if(obj == null) {
      return results
    }
    if(nativeMap && obj.map === nativeMap) {
      return obj.map(iterator, context)
    }
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list)
    });
    return results
  };
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = memo !== void 0;
    if(obj == null) {
      obj = []
    }
    if(nativeReduce && obj.reduce === nativeReduce) {
      if(context) {
        iterator = _.bind(iterator, context)
      }
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator)
    }
    each(obj, function(value, index, list) {
      if(!initial) {
        memo = value;
        initial = true
      }else {
        memo = iterator.call(context, memo, value, index, list)
      }
    });
    if(!initial) {
      throw new TypeError("Reduce of empty array with no initial value");
    }
    return memo
  };
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    if(obj == null) {
      obj = []
    }
    if(nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if(context) {
        iterator = _.bind(iterator, context)
      }
      return memo !== void 0 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator)
    }
    var reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();
    return _.reduce(reversed, iterator, memo, context)
  };
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if(iterator.call(context, value, index, list)) {
        result = value;
        return true
      }
    });
    return result
  };
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if(obj == null) {
      return results
    }
    if(nativeFilter && obj.filter === nativeFilter) {
      return obj.filter(iterator, context)
    }
    each(obj, function(value, index, list) {
      if(iterator.call(context, value, index, list)) {
        results[results.length] = value
      }
    });
    return results
  };
  _.reject = function(obj, iterator, context) {
    var results = [];
    if(obj == null) {
      return results
    }
    each(obj, function(value, index, list) {
      if(!iterator.call(context, value, index, list)) {
        results[results.length] = value
      }
    });
    return results
  };
  _.every = _.all = function(obj, iterator, context) {
    var result = true;
    if(obj == null) {
      return result
    }
    if(nativeEvery && obj.every === nativeEvery) {
      return obj.every(iterator, context)
    }
    each(obj, function(value, index, list) {
      if(!(result = result && iterator.call(context, value, index, list))) {
        return breaker
      }
    });
    return result
  };
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator = iterator || _.identity;
    var result = false;
    if(obj == null) {
      return result
    }
    if(nativeSome && obj.some === nativeSome) {
      return obj.some(iterator, context)
    }
    each(obj, function(value, index, list) {
      if(result |= iterator.call(context, value, index, list)) {
        return breaker
      }
    });
    return!!result
  };
  _.include = _.contains = function(obj, target) {
    var found = false;
    if(obj == null) {
      return found
    }
    if(nativeIndexOf && obj.indexOf === nativeIndexOf) {
      return obj.indexOf(target) != -1
    }
    found = any(obj, function(value) {
      if(value === target) {
        return true
      }
    });
    return found
  };
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return(method.call ? method || value : value[method]).apply(value, args)
    })
  };
  _.pluck = function(obj, key) {
    return _.map(obj, function(value) {
      return value[key]
    })
  };
  _.max = function(obj, iterator, context) {
    if(!iterator && _.isArray(obj)) {
      return Math.max.apply(Math, obj)
    }
    if(!iterator && _.isEmpty(obj)) {
      return-Infinity
    }
    var result = {computed:-Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value:value, computed:computed})
    });
    return result.value
  };
  _.min = function(obj, iterator, context) {
    if(!iterator && _.isArray(obj)) {
      return Math.min.apply(Math, obj)
    }
    if(!iterator && _.isEmpty(obj)) {
      return Infinity
    }
    var result = {computed:Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value:value, computed:computed})
    });
    return result.value
  };
  _.shuffle = function(obj) {
    var shuffled = [], rand;
    each(obj, function(value, index, list) {
      if(index == 0) {
        shuffled[0] = value
      }else {
        rand = Math.floor(Math.random() * (index + 1));
        shuffled[index] = shuffled[rand];
        shuffled[rand] = value
      }
    });
    return shuffled
  };
  _.sortBy = function(obj, iterator, context) {
    return _.pluck(_.map(obj, function(value, index, list) {
      return{value:value, criteria:iterator.call(context, value, index, list)}
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0
    }), "value")
  };
  _.groupBy = function(obj, val) {
    var result = {};
    var iterator = _.isFunction(val) ? val : function(obj) {
      return obj[val]
    };
    each(obj, function(value, index) {
      var key = iterator(value, index);
      (result[key] || (result[key] = [])).push(value)
    });
    return result
  };
  _.sortedIndex = function(array, obj, iterator) {
    iterator || (iterator = _.identity);
    var low = 0, high = array.length;
    while(low < high) {
      var mid = low + high >> 1;
      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid
    }
    return low
  };
  _.toArray = function(iterable) {
    if(!iterable) {
      return[]
    }
    if(iterable.toArray) {
      return iterable.toArray()
    }
    if(_.isArray(iterable)) {
      return slice.call(iterable)
    }
    if(_.isArguments(iterable)) {
      return slice.call(iterable)
    }
    return _.values(iterable)
  };
  _.size = function(obj) {
    return _.toArray(obj).length
  };
  _.first = _.head = function(array, n, guard) {
    return n != null && !guard ? slice.call(array, 0, n) : array[0]
  };
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n))
  };
  _.last = function(array, n, guard) {
    return n != null && !guard ? slice.call(array, array.length - n) : array[array.length - 1]
  };
  _.rest = _.tail = function(array, index, guard) {
    return slice.call(array, index == null || guard ? 1 : index)
  };
  _.compact = function(array) {
    return _.filter(array, function(value) {
      return!!value
    })
  };
  _.flatten = function(array, shallow) {
    return _.reduce(array, function(memo, value) {
      if(_.isArray(value)) {
        return memo.concat(shallow ? value : _.flatten(value))
      }
      memo[memo.length] = value;
      return memo
    }, [])
  };
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1))
  };
  _.uniq = _.unique = function(array, isSorted, iterator) {
    var initial = iterator ? _.map(array, iterator) : array;
    var result = [];
    _.reduce(initial, function(memo, el, i) {
      if(0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) {
        memo[memo.length] = el;
        result[result.length] = array[i]
      }
      return memo
    }, []);
    return result
  };
  _.union = function() {
    return _.uniq(_.flatten(arguments, true))
  };
  _.intersection = _.intersect = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0
      })
    })
  };
  _.difference = function(array, other) {
    return _.filter(array, function(value) {
      return!_.include(other, value)
    })
  };
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, "length"));
    var results = new Array(length);
    for(var i = 0;i < length;i++) {
      results[i] = _.pluck(args, "" + i)
    }
    return results
  };
  _.indexOf = function(array, item, isSorted) {
    if(array == null) {
      return-1
    }
    var i, l;
    if(isSorted) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1
    }
    if(nativeIndexOf && array.indexOf === nativeIndexOf) {
      return array.indexOf(item)
    }
    for(i = 0, l = array.length;i < l;i++) {
      if(array[i] === item) {
        return i
      }
    }
    return-1
  };
  _.lastIndexOf = function(array, item) {
    if(array == null) {
      return-1
    }
    if(nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return array.lastIndexOf(item)
    }
    var i = array.length;
    while(i--) {
      if(array[i] === item) {
        return i
      }
    }
    return-1
  };
  _.range = function(start, stop, step) {
    if(arguments.length <= 1) {
      stop = start || 0;
      start = 0
    }
    step = arguments[2] || 1;
    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);
    while(idx < len) {
      range[idx++] = start;
      start += step
    }
    return range
  };
  var ctor = function() {
  };
  _.bind = function bind(func, context) {
    var bound, args;
    if(func.bind === nativeBind && nativeBind) {
      return nativeBind.apply(func, slice.call(arguments, 1))
    }
    if(!_.isFunction(func)) {
      throw new TypeError;
    }
    args = slice.call(arguments, 2);
    return bound = function() {
      if(!(this instanceof bound)) {
        return func.apply(context, args.concat(slice.call(arguments)))
      }
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if(Object(result) === result) {
        return result
      }
      return self
    }
  };
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if(funcs.length == 0) {
      funcs = _.functions(obj)
    }
    each(funcs, function(f) {
      obj[f] = _.bind(obj[f], obj)
    });
    return obj
  };
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return hasOwnProperty.call(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments)
    }
  };
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function() {
      return func.apply(func, args)
    }, wait)
  };
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)))
  };
  _.throttle = function(func, wait) {
    var timeout, context, args, throttling, finishThrottle;
    finishThrottle = _.debounce(function() {
      throttling = false
    }, wait);
    return function() {
      context = this;
      args = arguments;
      var throttler = function() {
        timeout = null;
        func.apply(context, args);
        finishThrottle()
      };
      if(!timeout) {
        timeout = setTimeout(throttler, wait)
      }
      if(!throttling) {
        func.apply(context, args)
      }
      if(finishThrottle) {
        finishThrottle()
      }
      throttling = true
    }
  };
  _.debounce = function(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var throttler = function() {
        timeout = null;
        func.apply(context, args)
      };
      clearTimeout(timeout);
      timeout = setTimeout(throttler, wait)
    }
  };
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if(ran) {
        return memo
      }
      ran = true;
      return memo = func.apply(this, arguments)
    }
  };
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func].concat(slice.call(arguments));
      return wrapper.apply(this, args)
    }
  };
  _.compose = function() {
    var funcs = slice.call(arguments);
    return function() {
      var args = slice.call(arguments);
      for(var i = funcs.length - 1;i >= 0;i--) {
        args = [funcs[i].apply(this, args)]
      }
      return args[0]
    }
  };
  _.after = function(times, func) {
    return function() {
      if(--times < 1) {
        return func.apply(this, arguments)
      }
    }
  };
  _.keys = nativeKeys || function(obj) {
    if(obj !== Object(obj)) {
      throw new TypeError("Invalid object");
    }
    var keys = [];
    for(var key in obj) {
      if(hasOwnProperty.call(obj, key)) {
        keys[keys.length] = key
      }
    }
    return keys
  };
  _.values = function(obj) {
    return _.map(obj, _.identity)
  };
  _.functions = _.methods = function(obj) {
    var names = [];
    for(var key in obj) {
      if(_.isFunction(obj[key])) {
        names.push(key)
      }
    }
    return names.sort()
  };
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for(var prop in source) {
        if(source[prop] !== void 0) {
          obj[prop] = source[prop]
        }
      }
    });
    return obj
  };
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for(var prop in source) {
        if(obj[prop] == null) {
          obj[prop] = source[prop]
        }
      }
    });
    return obj
  };
  _.clone = function(obj) {
    if(!_.isObject(obj)) {
      return obj
    }
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj)
  };
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj
  };
  function eq(a, b, stack) {
    if(a === b) {
      return a !== 0 || 1 / a == 1 / b
    }
    if(a == null || b == null) {
      return a === b
    }
    if(a._chain) {
      a = a._wrapped
    }
    if(b._chain) {
      b = b._wrapped
    }
    if(_.isFunction(a.isEqual)) {
      return a.isEqual(b)
    }
    if(_.isFunction(b.isEqual)) {
      return b.isEqual(a)
    }
    var typeA = typeof a;
    if(typeA != typeof b) {
      return false
    }
    if(!a != !b) {
      return false
    }
    if(_.isNaN(a)) {
      return _.isNaN(b)
    }
    var isStringA = _.isString(a), isStringB = _.isString(b);
    if(isStringA || isStringB) {
      return isStringA && isStringB && String(a) == String(b)
    }
    var isNumberA = _.isNumber(a), isNumberB = _.isNumber(b);
    if(isNumberA || isNumberB) {
      return isNumberA && isNumberB && +a == +b
    }
    var isBooleanA = _.isBoolean(a), isBooleanB = _.isBoolean(b);
    if(isBooleanA || isBooleanB) {
      return isBooleanA && isBooleanB && +a == +b
    }
    var isDateA = _.isDate(a), isDateB = _.isDate(b);
    if(isDateA || isDateB) {
      return isDateA && isDateB && a.getTime() == b.getTime()
    }
    var isRegExpA = _.isRegExp(a), isRegExpB = _.isRegExp(b);
    if(isRegExpA || isRegExpB) {
      return isRegExpA && isRegExpB && a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase
    }
    if(typeA != "object") {
      return false
    }
    if(a.length !== b.length) {
      return false
    }
    if(a.constructor !== b.constructor) {
      return false
    }
    var length = stack.length;
    while(length--) {
      if(stack[length] == a) {
        return true
      }
    }
    stack.push(a);
    var size = 0, result = true;
    for(var key in a) {
      if(hasOwnProperty.call(a, key)) {
        size++;
        if(!(result = hasOwnProperty.call(b, key) && eq(a[key], b[key], stack))) {
          break
        }
      }
    }
    if(result) {
      for(key in b) {
        if(hasOwnProperty.call(b, key) && !size--) {
          break
        }
      }
      result = !size
    }
    stack.pop();
    return result
  }
  _.isEqual = function(a, b) {
    return eq(a, b, [])
  };
  _.isEmpty = function(obj) {
    if(_.isArray(obj) || _.isString(obj)) {
      return obj.length === 0
    }
    for(var key in obj) {
      if(hasOwnProperty.call(obj, key)) {
        return false
      }
    }
    return true
  };
  _.isElement = function(obj) {
    return!!(obj && obj.nodeType == 1)
  };
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == "[object Array]"
  };
  _.isObject = function(obj) {
    return obj === Object(obj)
  };
  if(toString.call(arguments) == "[object Arguments]") {
    _.isArguments = function(obj) {
      return toString.call(obj) == "[object Arguments]"
    }
  }else {
    _.isArguments = function(obj) {
      return!!(obj && hasOwnProperty.call(obj, "callee"))
    }
  }
  _.isFunction = function(obj) {
    return toString.call(obj) == "[object Function]"
  };
  _.isString = function(obj) {
    return toString.call(obj) == "[object String]"
  };
  _.isNumber = function(obj) {
    return toString.call(obj) == "[object Number]"
  };
  _.isNaN = function(obj) {
    return obj !== obj
  };
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == "[object Boolean]"
  };
  _.isDate = function(obj) {
    return toString.call(obj) == "[object Date]"
  };
  _.isRegExp = function(obj) {
    return toString.call(obj) == "[object RegExp]"
  };
  _.isNull = function(obj) {
    return obj === null
  };
  _.isUndefined = function(obj) {
    return obj === void 0
  };
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this
  };
  _.identity = function(value) {
    return value
  };
  _.times = function(n, iterator, context) {
    for(var i = 0;i < n;i++) {
      iterator.call(context, i)
    }
  };
  _.escape = function(string) {
    return("" + string).replace(/&(?!\w+;|#\d+;|#x[\da-f]+;)/gi, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;")
  };
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      addToWrapper(name, _[name] = obj[name])
    })
  };
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id
  };
  _.templateSettings = {evaluate:/<%([\s\S]+?)%>/g, interpolate:/<%=([\s\S]+?)%>/g, escape:/<%-([\s\S]+?)%>/g};
  _.template = function(str, data) {
    var c = _.templateSettings;
    var tmpl = "var __p=[],print=function(){__p.push.apply(__p,arguments);};" + "with(obj||{}){__p.push('" + str.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(c.escape, function(match, code) {
      return"',_.escape(" + code.replace(/\\'/g, "'") + "),'"
    }).replace(c.interpolate, function(match, code) {
      return"'," + code.replace(/\\'/g, "'") + ",'"
    }).replace(c.evaluate || null, function(match, code) {
      return"');" + code.replace(/\\'/g, "'").replace(/[\r\n\t]/g, " ") + "__p.push('"
    }).replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/\t/g, "\\t") + "');}return __p.join('');";
    var func = new Function("obj", tmpl);
    return data ? func(data) : func
  };
  var wrapper = function(obj) {
    this._wrapped = obj
  };
  _.prototype = wrapper.prototype;
  var result = function(obj, chain) {
    return chain ? _(obj).chain() : obj
  };
  var addToWrapper = function(name, func) {
    wrapper.prototype[name] = function() {
      var args = slice.call(arguments);
      unshift.call(args, this._wrapped);
      return result(func.apply(_, args), this._chain)
    }
  };
  _.mixin(_);
  each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      method.apply(this._wrapped, arguments);
      return result(this._wrapped, this._chain)
    }
  });
  each(["concat", "join", "slice"], function(name) {
    var method = ArrayProto[name];
    wrapper.prototype[name] = function() {
      return result(method.apply(this._wrapped, arguments), this._chain)
    }
  });
  wrapper.prototype.chain = function() {
    this._chain = true;
    return this
  };
  wrapper.prototype.value = function() {
    return this._wrapped
  }
})();
!function(name, definition) {
  if(typeof module != "undefined") {
    module.exports = definition()
  }else {
    if(typeof define == "function" && define.amd) {
      define(name, definition)
    }else {
      this[name] = definition()
    }
  }
}("bonzo", function() {
  var context = this, old = context.bonzo, win = window, doc = win.document, html = doc.documentElement, parentNode = "parentNode", query = null, specialAttributes = /^checked|value|selected$/, specialTags = /select|fieldset|table|tbody|tfoot|td|tr|colgroup/i, table = ["<table>", "</table>", 1], td = ["<table><tbody><tr>", "</tr></tbody></table>", 3], option = ["<select>", "</select>", 1], tagMap = {thead:table, tbody:table, tfoot:table, colgroup:table, caption:table, tr:["<table><tbody>", "</tbody></table>", 
  2], th:td, td:td, col:["<table><colgroup>", "</colgroup></table>", 2], fieldset:["<form>", "</form>", 1], legend:["<form><fieldset>", "</fieldset></form>", 2], option:option, optgroup:option}, stateAttributes = /^checked|selected$/, ie = /msie/i.test(navigator.userAgent), uidList = [], uuids = 0, digit = /^-?[\d\.]+$/, dattr = /^data-(.+)$/, px = "px", setAttribute = "setAttribute", getAttribute = "getAttribute", byTag = "getElementsByTagName", features = function() {
    var e = doc.createElement("p");
    e.innerHTML = '<a href="#x">x</a><table style="float:left;"></table>';
    return{hrefExtended:e[byTag]("a")[0][getAttribute]("href") != "#x", autoTbody:e[byTag]("tbody").length !== 0, computedStyle:doc.defaultView && doc.defaultView.getComputedStyle, cssFloat:e[byTag]("table")[0].style.styleFloat ? "styleFloat" : "cssFloat", transform:function() {
      var props = ["webkitTransform", "MozTransform", "OTransform", "msTransform", "Transform"], i;
      for(i = 0;i < props.length;i++) {
        if(props[i] in e.style) {
          return props[i]
        }
      }
    }()}
  }(), trimReplace = /(^\s*|\s*$)/g, unitless = {lineHeight:1, zoom:1, zIndex:1, opacity:1}, trim = String.prototype.trim ? function(s) {
    return s.trim()
  } : function(s) {
    return s.replace(trimReplace, "")
  };
  function classReg(c) {
    return new RegExp("(^|\\s+)" + c + "(\\s+|$)")
  }
  function each(ar, fn, scope) {
    for(var i = 0, l = ar.length;i < l;i++) {
      fn.call(scope || ar[i], ar[i], i, ar)
    }
    return ar
  }
  function camelize(s) {
    return s.replace(/-(.)/g, function(m, m1) {
      return m1.toUpperCase()
    })
  }
  function decamelize(s) {
    return s ? s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() : s
  }
  function data(el) {
    el[getAttribute]("data-node-uid") || el[setAttribute]("data-node-uid", ++uuids);
    uid = el[getAttribute]("data-node-uid");
    return uidList[uid] || (uidList[uid] = {})
  }
  function dataValue(d) {
    try {
      return d === "true" ? true : d === "false" ? false : d === "null" ? null : !isNaN(d) ? parseFloat(d) : d
    }catch(e) {
    }
    return undefined
  }
  function isNode(node) {
    return node && node.nodeName && node.nodeType == 1
  }
  function some(ar, fn, scope, i) {
    for(i = 0, j = ar.length;i < j;++i) {
      if(fn.call(scope, ar[i], i, ar)) {
        return true
      }
    }
    return false
  }
  function styleProperty(p) {
    p == "transform" && (p = features.transform) || /^transform-?[Oo]rigin$/.test(p) && (p = features.transform + "Origin") || p == "float" && (p = features.cssFloat);
    return p ? camelize(p) : null
  }
  var getStyle = features.computedStyle ? function(el, property) {
    var value = null, computed = doc.defaultView.getComputedStyle(el, "");
    computed && (value = computed[property]);
    return el.style[property] || value
  } : ie && html.currentStyle ? function(el, property) {
    if(property == "opacity") {
      var val = 100;
      try {
        val = el.filters["DXImageTransform.Microsoft.Alpha"].opacity
      }catch(e1) {
        try {
          val = el.filters("alpha").opacity
        }catch(e2) {
        }
      }
      return val / 100
    }
    var value = el.currentStyle ? el.currentStyle[property] : null;
    return el.style[property] || value
  } : function(el, property) {
    return el.style[property]
  };
  function insert(target, host, fn) {
    var i = 0, self = host || this, r = [], nodes = query && typeof target == "string" && target.charAt(0) != "<" ? query(target) : target;
    each(normalize(nodes), function(t) {
      each(self, function(el) {
        var n = !el[parentNode] || el[parentNode] && !el[parentNode][parentNode] ? function() {
          var c = el.cloneNode(true);
          self.$ && self.cloneEvents && self.$(c).cloneEvents(el);
          return c
        }() : el;
        fn(t, n);
        r[i] = n;
        i++
      })
    }, this);
    each(r, function(e, i) {
      self[i] = e
    });
    self.length = i;
    return self
  }
  function xy(el, x, y) {
    var $el = bonzo(el), style = $el.css("position"), offset = $el.offset(), rel = "relative", isRel = style == rel, delta = [parseInt($el.css("left"), 10), parseInt($el.css("top"), 10)];
    if(style == "static") {
      $el.css("position", rel);
      style = rel
    }
    isNaN(delta[0]) && (delta[0] = isRel ? 0 : el.offsetLeft);
    isNaN(delta[1]) && (delta[1] = isRel ? 0 : el.offsetTop);
    x != null && (el.style.left = x - offset.left + delta[0] + px);
    y != null && (el.style.top = y - offset.top + delta[1] + px)
  }
  function hasClass(el, c) {
    return classReg(c).test(el.className)
  }
  function addClass(el, c) {
    el.className = trim(el.className + " " + c)
  }
  function removeClass(el, c) {
    el.className = trim(el.className.replace(classReg(c), " "))
  }
  function setter(el, v) {
    return typeof v == "function" ? v(el) : v
  }
  function Bonzo(elements) {
    this.length = 0;
    if(elements) {
      elements = typeof elements !== "string" && !elements.nodeType && typeof elements.length !== "undefined" ? elements : [elements];
      this.length = elements.length;
      for(var i = 0;i < elements.length;i++) {
        this[i] = elements[i]
      }
    }
  }
  Bonzo.prototype = {get:function(index) {
    return this[index]
  }, each:function(fn, scope) {
    return each(this, fn, scope)
  }, map:function(fn, reject) {
    var m = [], n, i;
    for(i = 0;i < this.length;i++) {
      n = fn.call(this, this[i], i);
      reject ? reject(n) && m.push(n) : m.push(n)
    }
    return m
  }, first:function() {
    return bonzo(this.length ? this[0] : [])
  }, last:function() {
    return bonzo(this.length ? this[this.length - 1] : [])
  }, html:function(h, text) {
    var method = text ? html.textContent === undefined ? "innerText" : "textContent" : "innerHTML", m;
    function append(el) {
      while(el.firstChild) {
        el.removeChild(el.firstChild)
      }
      each(normalize(h), function(node) {
        el.appendChild(node)
      })
    }
    return typeof h !== "undefined" ? this.each(function(el) {
      !text && (m = el.tagName.match(specialTags)) ? append(el, m[0]) : el[method] = h
    }) : this[0] ? this[0][method] : ""
  }, text:function(text) {
    return this.html(text, 1)
  }, addClass:function(c) {
    return this.each(function(el) {
      hasClass(el, setter(el, c)) || addClass(el, setter(el, c))
    })
  }, removeClass:function(c) {
    return this.each(function(el) {
      hasClass(el, setter(el, c)) && removeClass(el, setter(el, c))
    })
  }, hasClass:function(c) {
    return some(this, function(el) {
      return hasClass(el, c)
    })
  }, toggleClass:function(c, condition) {
    return this.each(function(el) {
      typeof condition !== "undefined" ? condition ? addClass(el, c) : removeClass(el, c) : hasClass(el, c) ? removeClass(el, c) : addClass(el, c)
    })
  }, show:function(type) {
    return this.each(function(el) {
      el.style.display = type || ""
    })
  }, hide:function() {
    return this.each(function(el) {
      el.style.display = "none"
    })
  }, append:function(node) {
    return this.each(function(el) {
      each(normalize(node), function(i) {
        el.appendChild(i)
      })
    })
  }, prepend:function(node) {
    return this.each(function(el) {
      var first = el.firstChild;
      each(normalize(node), function(i) {
        el.insertBefore(i, first)
      })
    })
  }, appendTo:function(target, host) {
    return insert.call(this, target, host, function(t, el) {
      t.appendChild(el)
    })
  }, prependTo:function(target, host) {
    return insert.call(this, target, host, function(t, el) {
      t.insertBefore(el, t.firstChild)
    })
  }, next:function() {
    return this.related("nextSibling")
  }, previous:function() {
    return this.related("previousSibling")
  }, related:function(method) {
    return this.map(function(el) {
      el = el[method];
      while(el && el.nodeType !== 1) {
        el = el[method]
      }
      return el || 0
    }, function(el) {
      return el
    })
  }, before:function(node) {
    return this.each(function(el) {
      each(bonzo.create(node), function(i) {
        el[parentNode].insertBefore(i, el)
      })
    })
  }, after:function(node) {
    return this.each(function(el) {
      each(bonzo.create(node), function(i) {
        el[parentNode].insertBefore(i, el.nextSibling)
      })
    })
  }, insertBefore:function(target, host) {
    return insert.call(this, target, host, function(t, el) {
      t[parentNode].insertBefore(el, t)
    })
  }, insertAfter:function(target, host) {
    return insert.call(this, target, host, function(t, el) {
      var sibling = t.nextSibling;
      if(sibling) {
        t[parentNode].insertBefore(el, sibling)
      }else {
        t[parentNode].appendChild(el)
      }
    })
  }, replaceWith:function(html) {
    return this.each(function(el) {
      el.parentNode.replaceChild(bonzo.create(html)[0], el)
    })
  }, css:function(o, v, p) {
    if(v === undefined && typeof o == "string") {
      v = this[0];
      if(!v) {
        return null
      }
      if(v === doc || v === win) {
        p = v === doc ? bonzo.doc() : bonzo.viewport();
        return o == "width" ? p.width : o == "height" ? p.height : ""
      }
      return(o = styleProperty(o)) ? getStyle(v, o) : null
    }
    var iter = o;
    if(typeof o == "string") {
      iter = {};
      iter[o] = v
    }
    if(ie && iter.opacity) {
      iter.filter = "alpha(opacity=" + iter.opacity * 100 + ")";
      iter.zoom = o.zoom || 1;
      delete iter.opacity
    }
    function fn(el, p, v) {
      for(var k in iter) {
        if(iter.hasOwnProperty(k)) {
          v = iter[k];
          (p = styleProperty(k)) && digit.test(v) && !(p in unitless) && (v += px);
          el.style[p] = setter(el, v)
        }
      }
    }
    return this.each(fn)
  }, offset:function(x, y) {
    if(typeof x == "number" || typeof y == "number") {
      return this.each(function(el) {
        xy(el, x, y)
      })
    }
    if(!this[0]) {
      return{top:0, left:0, height:0, width:0}
    }
    var el = this[0], width = el.offsetWidth, height = el.offsetHeight, top = el.offsetTop, left = el.offsetLeft;
    while(el = el.offsetParent) {
      top = top + el.offsetTop;
      left = left + el.offsetLeft
    }
    return{top:top, left:left, height:height, width:width}
  }, dim:function() {
    var el = this[0], orig = !el.offsetWidth && !el.offsetHeight ? function(t, s) {
      s = {position:el.style.position || "", visibility:el.style.visibility || "", display:el.style.display || ""};
      t.first().css({position:"absolute", visibility:"hidden", display:"block"});
      return s
    }(this) : null, width = el.offsetWidth, height = el.offsetHeight;
    orig && this.first().css(orig);
    return{height:height, width:width}
  }, attr:function(k, v) {
    var el = this[0];
    if(typeof k != "string" && !(k instanceof String)) {
      for(var n in k) {
        k.hasOwnProperty(n) && this.attr(n, k[n])
      }
      return this
    }
    return typeof v == "undefined" ? specialAttributes.test(k) ? stateAttributes.test(k) && typeof el[k] == "string" ? true : el[k] : (k == "href" || k == "src") && features.hrefExtended ? el[getAttribute](k, 2) : el[getAttribute](k) : this.each(function(el) {
      specialAttributes.test(k) ? el[k] = setter(el, v) : el[setAttribute](k, setter(el, v))
    })
  }, val:function(s) {
    return typeof s == "string" ? this.attr("value", s) : this[0].value
  }, removeAttr:function(k) {
    return this.each(function(el) {
      stateAttributes.test(k) ? el[k] = false : el.removeAttribute(k)
    })
  }, data:function(k, v) {
    var el = this[0], uid, o, m;
    if(typeof v === "undefined") {
      o = data(el);
      if(typeof k === "undefined") {
        each(el.attributes, function(a) {
          (m = ("" + a.name).match(dattr)) && (o[camelize(m[1])] = dataValue(a.value))
        });
        return o
      }else {
        return typeof o[k] === "undefined" ? o[k] = dataValue(this.attr("data-" + decamelize(k))) : o[k]
      }
    }else {
      return this.each(function(el) {
        data(el)[k] = v
      })
    }
  }, remove:function() {
    return this.each(function(el) {
      el[parentNode] && el[parentNode].removeChild(el)
    })
  }, empty:function() {
    return this.each(function(el) {
      while(el.firstChild) {
        el.removeChild(el.firstChild)
      }
    })
  }, detach:function() {
    return this.map(function(el) {
      return el[parentNode].removeChild(el)
    })
  }, scrollTop:function(y) {
    return scroll.call(this, null, y, "y")
  }, scrollLeft:function(x) {
    return scroll.call(this, x, null, "x")
  }, toggle:function(callback) {
    this.each(function(el) {
      el.style.display = el.offsetWidth || el.offsetHeight ? "none" : "block"
    });
    callback && callback();
    return this
  }};
  function normalize(node) {
    return typeof node == "string" ? bonzo.create(node) : isNode(node) ? [node] : node
  }
  function scroll(x, y, type) {
    var el = this[0];
    if(x == null && y == null) {
      return(isBody(el) ? getWindowScroll() : {x:el.scrollLeft, y:el.scrollTop})[type]
    }
    if(isBody(el)) {
      win.scrollTo(x, y)
    }else {
      x != null && (el.scrollLeft = x);
      y != null && (el.scrollTop = y)
    }
    return this
  }
  function isBody(element) {
    return element === win || /^(?:body|html)$/i.test(element.tagName)
  }
  function getWindowScroll() {
    return{x:win.pageXOffset || html.scrollLeft, y:win.pageYOffset || html.scrollTop}
  }
  function bonzo(els, host) {
    return new Bonzo(els, host)
  }
  bonzo.setQueryEngine = function(q) {
    query = q;
    delete bonzo.setQueryEngine
  };
  bonzo.aug = function(o, target) {
    for(var k in o) {
      o.hasOwnProperty(k) && ((target || Bonzo.prototype)[k] = o[k])
    }
  };
  bonzo.create = function(node) {
    return typeof node == "string" && node !== "" ? function() {
      var tag = /^\s*<([^\s>]+)/.exec(node), el = doc.createElement("div"), els = [], p = tag ? tagMap[tag[1].toLowerCase()] : null, dep = p ? p[2] + 1 : 1, pn = parentNode, tb = features.autoTbody && p && p[0] == "<table>" && !/<tbody/i.test(node);
      el.innerHTML = p ? p[0] + node + p[1] : node;
      while(dep--) {
        el = el.firstChild
      }
      do {
        if((!tag || el.nodeType == 1) && (!tb || el.tagName.toLowerCase() != "tbody")) {
          els.push(el)
        }
      }while(el = el.nextSibling);
      each(els, function(el) {
        el[pn] && el[pn].removeChild(el)
      });
      return els
    }() : isNode(node) ? [node.cloneNode(true)] : []
  };
  bonzo.doc = function() {
    var vp = bonzo.viewport();
    return{width:Math.max(doc.body.scrollWidth, html.scrollWidth, vp.width), height:Math.max(doc.body.scrollHeight, html.scrollHeight, vp.height)}
  };
  bonzo.firstChild = function(el) {
    for(var c = el.childNodes, i = 0, j = c && c.length || 0, e;i < j;i++) {
      if(c[i].nodeType === 1) {
        e = c[j = i]
      }
    }
    return e
  };
  bonzo.viewport = function() {
    return{width:ie ? html.clientWidth : self.innerWidth, height:ie ? html.clientHeight : self.innerHeight}
  };
  bonzo.isAncestor = "compareDocumentPosition" in html ? function(container, element) {
    return(container.compareDocumentPosition(element) & 16) == 16
  } : "contains" in html ? function(container, element) {
    return container !== element && container.contains(element)
  } : function(container, element) {
    while(element = element[parentNode]) {
      if(element === container) {
        return true
      }
    }
    return false
  };
  bonzo.noConflict = function() {
    context.bonzo = old;
    return this
  };
  return bonzo
});
var d, getAllowedSites, getOption, getPrefix;
getPrefix = function() {
  return"cgt_"
};
getOption = function(key, value) {
  return localStorage[getPrefix() + key]
};
getAllowedSites = function() {
  return getOption("allowed_sites")
};
chrome.extension.onRequest.addListener(d = function(request, sender, sendResponse) {
  if(request.method === "getAllowedSites") {
    return sendResponse({result:getAllowedSites()})
  }else {
    return sendResponse({})
  }
});

